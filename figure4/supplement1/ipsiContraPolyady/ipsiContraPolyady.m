%% This script generates Figure 4â€“figure supplement 1 panel E
%
% The goal of this code is to generate a figure showing mean divergence,
% polyady, of ipsi and contra output synapses

%% Load annotations and connectors

% Load annotations json. Generated by gen_annotation_map.py
annotations=loadjson('../../../tracing/sid_by_annotation.json');

% Return all skeleton IDs for R and L ORNs
ORNs_Left=annotations.Left_0x20_ORN;
ORNs_Right=annotations.Right_0x20_ORN;
ORNs=[ORNs_Left, ORNs_Right];

% return all skeleton IDs of DM6 PNs
PNs=sort(annotations.DM6_0x20_PN);

% Load the connector structure
load('../../../tracing/conns.mat')

%% Load the axon postsynaptic skeleton lists
% Requires skeleton JSONs. Skip to next section to load saved data.

%for each ORN
for o=1:length(ORNs)
    o
    tic
    % Step #1 load ORN skeletons
    workingSkel=loadjson(['../../../tracing/skeletons/',num2str(ORNs(o)),'.json']);
    
    
    % STEP 2: generate the directed, weighted adjacency matrix and graph obj
    %also return the list of skeleton vertex names that went into this
    %adjacency matrix
    [adjMat, skelVertNames]=getSkelAdjMat_DW_ORN(workingSkel);
    
    
    %matrix is transposed to reflect my view of parent/child relationships,
    %this is troublesome because I dont think it should be the
    %case******!!!!!!!! TALK W? WEI ABOUT THIS
    adjMat=adjMat';
    
    %make a biograph object out of it
    G=biograph(adjMat);
    
    
    % This loop runs over the the verts that will go into the Adj Mat and looks for
    % the start of the left axon/s
    axonCounter=1;
    start=[];
    
    for v =1:length(skelVertNames)
        
        if isempty(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels)) == 1
        else
            
            if regexp(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels),'left axon') == 1
                
                start(axonCounter)=v;
                
                %leftStartNodeName=skelVertNames(v)
                axonCounter=axonCounter+1;
                
            else
            end
        end
    end
    
     % left axon node was improperly placed on ORN 15, use node
    % 693320 instead.
    
    if o == 34
        
        start=find(strcmp('x0x36_93320', skelVertNames));
    else
    end
    
    %check to see if there is a left axon, for our one unilateral R ORN there
    %will not be
    if isempty(start)
        
  
    else
        synCounter=1;
        
        for s = 1:length(start)
            % step 4 identify all nodes that are descendants of the left axon start
            
            
            %Traverse the graph from the left axon start vertex, as long as this node has
            %all the glomerular collateral as descendants and no connection back to its
            %parent this should yield the indicies of all nodes (from skelVertNames)
            %involved in the collateral
            leftAxonInds=G.traverse(start(s));
            
            %In this strange case the left axon is returned as the commisure segment.
            %Since it is a right ORN I will take the left axon to be anything left of
            %the midline that is left over when we remove the commisure vertices from
            %our list
            
            if o == 33
                
                allInds=1:length(adjMat);
                correctedLeftAxInds=allInds;
                correctedLeftAxInds(leftAxonInds)=[];
                leftAxonInds=correctedLeftAxInds;
                
                counter=1;
                for k=1:numel(leftAxonInds)
                    
                    if workingSkel.vertices.(cell2mat(skelVertNames(leftAxonInds(k)))).x<4.4*10^5
                        
                        rightSideVerts(counter)=k;
                        counter=counter+1;
                        
                    else
                    end
                    
                    
                end
                
                leftAxonInds(rightSideVerts)=[];
                
            else
            end
            
            
            %In some cases the 'left axon' tag is on the wrong side of the root node so
            %the traverse above returns all nodes other than those from the left axon.
            % I am dealing with this by identifying all cases in which the "left axon"
            % consists of more than 2k nodes and simply taking the inverse set of
            % indicies in these cases
            
            if numel(leftAxonInds)>2000
                
                allInds=1:length(adjMat);
                correctedLeftAxInds=allInds;
                correctedLeftAxInds(leftAxonInds)=[];
                leftAxonInds=correctedLeftAxInds;
                
            else
                
            end
            
            
          
            
            
            % Step 5 We want to calculate the total path length of this subgraph
            
            %NOTE:NEED SOME WAY TO CHECK THIS, nC answer is slightly different
            
            %For now I guess I am going to do this by pulling values from my adjacency
            %matrix, there is probably a smarter/more elegant way to do this
            
          
            % Step 6 find all postsynaptic profiles sites in this subarbor
            
            
            
            
            for v=leftAxonInds
                
                children=fieldnames(workingSkel.connectivity.(cell2mat(skelVertNames(v))));
                
                for c=1:length(children)
                    
                    if strcmp(workingSkel.connectivity.(cell2mat(skelVertNames(v))).(cell2mat(children(c))).type, 'postsynaptic_to') == 1
                       
                      
                        leftPostSkelsBySyn{o}{synCounter}= conns.(cell2mat(children(c))).post;
                        synCounter=synCounter+1;
                        
                        
                    else
                    end
                end
            end
            
           
            
            
        end
        
    end
    

  
  
  
    
    % This loop runs over the the verts that will go into the Adj Mat and looks for
    % the start of the right axons
    
    axonCounterR=1;
    rightStart=[];
    
    for v =1:length(skelVertNames)
        
        if isempty(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels)) == 1
        else
            
            if regexp(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels),'right axon') == 1
                
                rightStart(axonCounterR)=v;
                %leftStartNodeName=skelVertNames(v)
                axonCounterR=axonCounterR+1;
                
            else
            end
        end
    end
    
    %check to see if there is a right axon, for our one unilateral L ORN there
    %will not be
    if isempty(rightStart)
        
      
        
    else
        
        synCounter=1;
        
        for s = 1:length(rightStart)
            % step 4 identify all nodes that are descendants of the right axon starts
            
            
            %Traverse the graph from the left axon start vertex, as long as this node has
            %all the glomerular collateral as descendants and no connection back to its
            %parent this should yield the indicies of all nodes (from skelVertNames)
            %involved in the collateral
            
            if o==43
                
                rightAxonInds=unique([G.traverse(rightStart),G.traverse(2346)]);
            else
                
                
                rightAxonInds=G.traverse(rightStart(s));
            end
            
           
            
            % Step 6 find all presynaptic sites in this subarbor
            
            
            
            for v=rightAxonInds
                
                children=fieldnames(workingSkel.connectivity.(cell2mat(skelVertNames(v))));
                
                for c=1:length(children)
                    
                    if strcmp(workingSkel.connectivity.(cell2mat(skelVertNames(v))).(cell2mat(children(c))).type, 'postsynaptic_to') == 1
                        
                        rightPostSkelsBySyn{o}{synCounter}= conns.(cell2mat(children(c))).post;
                        synCounter=synCounter+1;
                        
                        
                    else
                    end
                end
            end
            
            
            
            
        end
    end
    
  
   
    
   
  
    toc
end

save('../../../data/ipsiContraPolyady/rightPostSkelsBySyn/','rightPostSkelsBySyn')
save('../../../data/ipsiContraPolyady/leftPostSkelsBySyn','leftPostSkelsBySyn')



%% Collect conn nums 

load('../../../data/ipsiContraPolyady/rightPostSkelsBySyn')
load('../../../data/ipsiContraPolyady/leftPostSkelsBySyn')


% For each ORN collect its total number of connections within each
% glomerulus as well as the total number of PN connections

leftCounter=1;
rightCounter=1;

for o=1:length(ORNs)
    
    leftRunT=[];
    leftRunP=[];
    leftRunDiv=[];
   
    
    
    for j=1:size(leftPostSkelsBySyn{o},2)
        
        leftRunT=[leftRunT, leftPostSkelsBySyn{o}{j}];
        leftRunP=[leftRunP,leftPostSkelsBySyn{o}{j}(ismember(leftPostSkelsBySyn{o}{j},PNs))];
        leftRunDiv=[leftRunDiv,numel(leftPostSkelsBySyn{o}{j})];
    end
    
    if isempty(leftRunP)==1
        
    else
        
        leftTotCon(leftCounter)=numel(leftRunT);
        leftPNCon(leftCounter)=numel(leftRunP);
        leftMeanDivergence(leftCounter)=mean(leftRunDiv);
        leftDivergence{o}=leftRunDiv;
        leftCounter=leftCounter+1;
        
    end
    
    rightRunT=[];
    rightRunP=[];
    rightRunDiv=[];
   
    
    
    for j=1:size(rightPostSkelsBySyn{o},2)
        
        rightRunT=[rightRunT, rightPostSkelsBySyn{o}{j}];
        rightRunP=[rightRunP,rightPostSkelsBySyn{o}{j}(ismember(rightPostSkelsBySyn{o}{j},PNs))];
        rightRunDiv=[rightRunDiv,numel(rightPostSkelsBySyn{o}{j})];
    end
    
    if isempty(rightRunP)==1
        
    else
        
        rightTotCon(rightCounter)=numel(rightRunT);
        rightPNCon(rightCounter)=numel(rightRunP);
        rightMeanDivergence(rightCounter)=mean(rightRunDiv);
        rightDivergence{o}=rightRunDiv;
        rightCounter=rightCounter+1;
        
    end
end


%% plotting

figure()
set(gcf, 'Color', 'w')

h=boxplot( [leftMeanDivergence(1:27),rightMeanDivergence(27:end),...
    leftMeanDivergence(28:end),rightMeanDivergence(1:26)]', [ones(53,1); 2*ones(51,1)],...
    'Color', 'k', 'Notch','on');
ax=gca;
ax.XTickLabel={'ipsi','contra'};
ylabel('Synaptic Divergence (edges/tbar)', 'Fontsize',16)
ylim([0 5])
ax.YTick=[0:1:5];
ax.FontSize=16;
axis square

saveas(gcf,'ipsiContraPolyady')
saveas(gcf,'ipsiContraPolyady','epsc')


%% Permutation test
nPerm = 10000;

% synaptic divergence (polyady) p < 0.0001, 10000 perms
sa = [leftMeanDivergence(1:27),rightMeanDivergence(27:end)]';
sb = [leftMeanDivergence(28:end),rightMeanDivergence(1:26)]';

sh0 = [sa; sb];

m = length(sa); 
n = length(sb); 

d_empirical = mean(sa) - mean(sb);

sa_rand = zeros(m,nPerm);
sb_rand = zeros(n,nPerm);
tic
for ii = 1:nPerm
    sa_rand(:,ii) = randsample(sh0,m);%,true);
    sb_rand(:,ii) = randsample(sh0,n);%,true);
end
toc
% Now we compute the differences between the means of these resampled
% samples.
% d = median(sb_rand) - median(sa_rand);
d = mean(sa_rand) - mean(sb_rand);

%
figure;
% [nn,xx] = hist(d,100);
% bar(xx,nn/sum(nn))
histogram(d,'Normalization','probability')
ylabel('Probability of occurrence')
xlabel('Difference between means')
hold on
%

y = get(gca,'yLim'); % y(2) is the maximum value on the y-axis.
x = get(gca,'xLim'); % x(1) is the minimum value on the x-axis.
plot([d_empirical,d_empirical],y*.99,'r-','lineWidth',2)

% Probability of H0 being true = 
% (# randomly obtained values > observed value)/total number of simulations
p = sum(abs(d) > abs(d_empirical))/length(d);
text(x(1)+(.01*(abs(x(1))+abs(x(2)))),y(2)*.95,sprintf('H0 is true with %4.4f probability.',p))